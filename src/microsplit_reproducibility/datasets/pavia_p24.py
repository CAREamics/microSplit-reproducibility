"""
Here, we load the raw old_dataset generated by Pezzotti from Pavia (2 channel old_dataset which does not have the input channel).
"""

import os
from enum import Enum
from functools import partial

import numpy as np
from careamics.lvae_training.dataset.types import DataSplitType
from nd2reader import ND2Reader

from microsplit_reproducibility.datasets.multifile_raw_dataloader import (
    get_train_val_data as get_train_val_data_twochannels,
    load_tiff,
    SubDsetType,
)


class Pavia3SeqPowerLevel(Enum):
    High = "High"
    Medium = "Medium"
    Low = "Low"

    @staticmethod
    def subdir(power_level):
        return {
            Pavia3SeqPowerLevel.High: "Main",
            Pavia3SeqPowerLevel.Medium: "Divided_2",
            Pavia3SeqPowerLevel.Low: "Divided_4",
        }[power_level]


class Pavia3SeqAlpha(Enum):
    Balanced = "Balanced"
    MediumSkew = "MediumSkew"
    HighSkew = "HighSkew"

    @staticmethod
    def subdir(alpha_level):
        return {
            Pavia3SeqAlpha.Balanced: "Cond_1",
            Pavia3SeqAlpha.MediumSkew: "Cond_2",
            Pavia3SeqAlpha.HighSkew: "Cond_3",
        }[alpha_level]


def load_one_file(fpath):
    if get_extension(fpath) == "nd2":
        return load_one_file_nd2(fpath)
    elif get_extension(fpath) == "tif":
        return load_tiff(fpath)


def load_one_file_nd2(fpath):
    """
    '/group/jug/ashesh/old_dataset/pavia3_sequential/Cond_2/Main/1_002.nd2'
    """
    output = {}
    with ND2Reader(fpath) as fobj:
        for c in range(len(fobj.metadata["channels"])):
            output[c] = []
            for z in fobj.metadata["z_levels"]:
                img = fobj.get_frame_2D(c=c, z=z)
                img = img[None, ..., None]
                output[c].append(img)
            output[c] = np.concatenate(output[c], axis=0)
    return np.concatenate([output[0], output[1]], axis=-1)


def get_extension(fpath):
    return os.path.basename(fpath).split(".")[-1]


def get_multi_channel_files(rootdatadir, power_level, alpha_level):
    dset_subdir = os.path.join(
        Pavia3SeqAlpha.subdir(alpha_level), Pavia3SeqPowerLevel.subdir(power_level)
    )
    subdir = os.path.join(rootdatadir, dset_subdir)
    fpaths = []
    for fname in os.listdir(subdir):
        fpath = os.path.join(dset_subdir, fname)
        extension = get_extension(fpath)
        if extension == "json":
            continue
        assert extension in ["tif", "nd2"]
        fpaths.append(fpath)

    fpaths = sorted(fpaths)
    return fpaths


def get_train_val_data(
    data_config,
    datadir,
    datasplit_type: DataSplitType = DataSplitType.Train,
    val_fraction=None,
    test_fraction=None,
    **kwargs
):
    assert data_config.subdset_type == SubDsetType.MultiChannel
    power_level = data_config.power_level
    alpha_level = data_config.alpha_level

    fpath_getter = partial(get_multi_channel_files, datadir, power_level, alpha_level)
    test_idx = data_config.test_idx
    val_idx = data_config.val_idx
    return get_train_val_data_twochannels(
        datadir,
        data_config,
        datasplit_type,
        fpath_getter,
        load_data_fn=load_one_file,
        val_fraction=val_fraction,
        test_fraction=test_fraction,
        explicit_val_idx=val_idx,
        explicit_test_idx=test_idx,
    )
